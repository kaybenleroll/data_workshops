---
title: "Building Transactional Frequency Models"
author: "Mick Cooney <mickcooney@gmail.com>"
date: "Last updated: `r format(Sys.time(), '%B %d, %Y')`"
output:
  rmdformats::readthedown:
    toc_depth: 3
    use_bookdown: TRUE
    code_folding: hide
    fig_caption: TRUE

  html_document:
    fig_caption: yes
    theme: spacelab #sandstone #spacelab #flatly
    highlight: pygments
    number_sections: TRUE
    toc: TRUE
    toc_depth: 2
    toc_float:
      smooth_scroll: FALSE

  pdf_document: default
---


```{r import_libraries, echo=FALSE, message=FALSE}
library(conflicted)
library(tidyverse)
library(scales)
library(cowplot)
library(directlabels)
library(magrittr)
library(rlang)
library(fs)
library(purrr)
library(furrr)
library(glue)
library(cmdstanr)
library(brms)
library(posterior)
library(bayesplot)
library(tidybayes)


source("lib_utils.R")

conflict_lst <- resolve_conflicts(
  c("magrittr", "rlang", "dplyr", "readr", "purrr", "ggplot2")
  )


knitr::opts_chunk$set(
  tidy       = FALSE,
  cache      = FALSE,
  warning    = FALSE,
  message    = FALSE,
  fig.height =     8,
  fig.width  =    11
  )

options(
  width        = 80L,
  warn         = 1,
  brms.backend = "cmdstanr",
  mc.cores     = parallel::detectCores()
  )

theme_set(theme_cowplot())

set.seed(42)

plan(multisession)
```

In this workbook we investigate different ways to model the transaction
frequency of individual customers, with a view to expanding this approach into
a more traditional P/NBD model.

# Load and Configure Datasets

We first want to load some synthetic transaction data.

```{r load_synth_transaction_data, echo=TRUE}
customer_cohort_tbl <- read_rds("data/synthdata_singleyear_cohort_tbl.rds")
customer_cohort_tbl %>% glimpse()

customer_simparams_tbl <- read_rds("data/synthdata_singleyear_simparams_tbl.rds")
customer_simparams_tbl %>% glimpse()

customer_transactions_tbl <- read_rds("data/synthdata_singleyear_transactions_tbl.rds")
customer_transactions_tbl %>% glimpse()
```


## Construct Frequency Data

```{r construct_frequency_modelling_data, echo=TRUE}
customer_summarystats_tbl <- customer_transactions_tbl %>%
  group_by(customer_id) %>%
  summarise(
    .groups = "drop",
    
    tnx_count    = n(),
    first_tnx_ts = min(tnx_timestamp),
    last_tnx_ts  = max(tnx_timestamp),
    all_weeks    = 52,
    tnx_weeks    = difftime(last_tnx_ts, first_tnx_ts, units = "weeks") %>% as.numeric(),
    btyd_count   = tnx_count - 1,
    obs_freq     = btyd_count / tnx_weeks,
    emp_freq     = btyd_count / all_weeks
    )

customer_summarystats_tbl %>% glimpse()
```

We want to view the transactions to get a sense of how regular our transactions
are in general.

```{r plot_customer_transaction_times, echo=TRUE}
plot_tbl <- customer_transactions_tbl %>%
  group_nest(customer_id, .key = "cust_data") %>%
  filter(map_int(cust_data, nrow) > 3) %>%
  slice_sample(n = 30) %>%
  unnest(cust_data)

ggplot(plot_tbl, aes(x = tnx_timestamp, y = customer_id)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Date",
    y = "Customer ID",
    title = "Visualisation of Customer Transaction Times"
    ) +
  theme(axis.text.y = element_text(size = 10))
```


## Construct Data Subsets

For the purposes of saving on time and computation, we construct a subset of
the data first, and rather than constructing different samples each time we
instead construct sets of `customer_id` to draw upon, then using those list
of values when we want to take a subset.

We do this by randomly shuffling the data

```{r construct_data_subset_ids, echo=TRUE}
shuffle_tbl <- customer_summarystats_tbl %>%
  slice_sample(n = nrow(.), replace = FALSE)

id_1000  <- shuffle_tbl %>% head(1000)  %>% pull(customer_id) %>% sort()
id_5000  <- shuffle_tbl %>% head(5000)  %>% pull(customer_id) %>% sort()
id_10000 <- shuffle_tbl %>% head(10000) %>% pull(customer_id) %>% sort()
```

We now have a list of `customer_id` values we use to subset the data.


# Construct Flat Frequency Model

For first frequency model we fit each customer's transaction frequency
independent of the other customers. We start with the estimation that the
average customer frequency is about one transaction every four weeks (once a
month) so this value determines our initial prior distribution for the
transaction frequency.

For our initial fit, we use only 1,000 eligible customers to reduce computation
time.


## Fit brms Model

To start with we fit our model using `brms` as this provides a large amount
of infrastructure and additional functionality that may be of use.

```{r fit_flat_brms_frequency_model, echo=TRUE}
fit_data_tbl <- customer_summarystats_tbl %>%
  filter(
    customer_id %in% id_1000,
    btyd_count > 0
    )

freqmodel_flat_brmfit <- brm(
  formula = btyd_count | rate(all_weeks) ~ 0 + customer_id,
  data    = fit_data_tbl,
  family  = poisson(),
  prior   = c(
    set_prior("gamma(1, 4)", class = "b", lb = 0)
    ),
  warmup   = 500,
  iter     = 1000,
  chains   = 4,
  seed     = 421
  )
```


Now that we have fit the model we want to see how well our posterior
distribution is covering the 'correct' values.

```{r construct_flat_freq_model_check, echo=TRUE}
freqmodel_flat_postcheck_tbl <- freqmodel_flat_brmfit %>%
  tidy_draws() %>%
  pivot_longer(
    !c(.chain, .iteration, .draw),
    names_prefix = "b_customer_id",
    names_to     = "customer_id",
    values_to    = "post_freqmean"
    ) %>%
  inner_join(customer_simparams_tbl, by = "customer_id") %>%
  select(.draw, customer_id, customer_lambda, post_freqmean)


freqmodel_flat_postcheck_qvals_tbl <- freqmodel_flat_postcheck_tbl %>%
  calculate_distribution_qvals(post_freqmean, customer_lambda, customer_id)

freqmodel_flat_postcheck_qvals_tbl %>% glimpse()
```


## Fit Stan Model

```{r compile_freqmodel_flat_stanmodel, echo=TRUE}
freqmodel_flat_stanmodel <- cmdstan_model(
  "stan_code/freqmodel_flat.stan",
  include_paths = "stan_code/",
  pedantic      =  TRUE,
  dir           = "stan_models/"
  )
```


```{r fit_freqmodel_flat_stanmodel, echo=TRUE}
stan_data_lst <- fit_data_tbl %>%
  select(customer_id, btyd_count, tnx_weeks) %>%
  compose_data(
    r     =  1,
    alpha =  4
    )

freqmodel_flat_stanfit <- freqmodel_flat_stanmodel$sample(
  data            =                stan_data_lst,
  chains          =                            4,
  iter_warmup     =                         1000,
  iter_sampling   =                         1000,
  seed            =                          421,
  output_dir      =                "stan_models",
  output_basename =             "freqmodel_flat"
  )

freqmodel_flat_stanfit$cmdstan_summary()
```

We first want to check the HMC diagnostics.

```{r calculate_freqmodel_flat_hmc_diagnostics, echo=TRUE}
freqmodel_flat_stanfit$cmdstan_diagnose()
```



# R Environment

```{r show_session_info, echo=TRUE, message=TRUE}
options(width = 120L)
sessioninfo::session_info()
options(width = 80L)
```
