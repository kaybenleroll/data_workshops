---
title: "Building Customer Lifetime Models"
author: "Mick Cooney <mickcooney@gmail.com>"
date: "Last updated: `r format(Sys.time(), '%B %d, %Y')`"
output:
  rmdformats::readthedown:
    toc_depth: 3
    use_bookdown: TRUE
    code_folding: hide
    fig_caption: TRUE

  html_document:
    fig_caption: yes
    theme: spacelab #sandstone #spacelab #flatly
    highlight: pygments
    number_sections: TRUE
    toc: TRUE
    toc_depth: 2
    toc_float:
      smooth_scroll: FALSE

  pdf_document: default
---


```{r import_libraries, echo=FALSE, message=FALSE}
library(conflicted)
library(tidyverse)
library(scales)
library(cowplot)
library(directlabels)
library(magrittr)
library(rlang)
library(fs)
library(purrr)
library(furrr)
library(glue)
library(cmdstanr)
library(brms)
library(posterior)
library(bayesplot)
library(tidybayes)


source("lib_utils.R")
source("lib_btyd.R")

conflict_lst <- resolve_conflicts(
  c("magrittr", "rlang", "dplyr", "readr", "purrr", "ggplot2")
  )


knitr::opts_chunk$set(
  tidy       = FALSE,
  cache      = FALSE,
  warning    = FALSE,
  message    = FALSE,
  fig.height =     8,
  fig.width  =    11
  )

options(
  width        = 80L,
  warn         = 1,
  brms.backend = "cmdstanr",
  mc.cores     = parallel::detectCores()
  )

theme_set(theme_cowplot())

set.seed(42)

plan(multisession)
```

In this workbook we investigate different ways to model the lifetime of
individual customers, with a view to expanding this approach with our
frequency into a more traditional P/NBD model.


# Load and Configure Datasets

We first want to load some synthetic transaction data with a fixed transaction
frequency which allowed for a varying lifetime.


```{r load_synth_transaction_data, echo=TRUE}
customer_cohort_tbl <- read_rds("data/synthdata_lifetime_cohort_tbl.rds")
customer_cohort_tbl %>% glimpse()

customer_simparams_tbl <- read_rds("data/synthdata_lifetime_simparams_tbl.rds")
customer_simparams_tbl %>% glimpse()

customer_transactions_tbl <- read_rds("data/synthdata_lifetime_transactions_tbl.rds")
customer_transactions_tbl %>% glimpse()
```

We also want to set up a number of parameters for use in this workbook

```{r setup_workbook_parameters, echo=TRUE}
stan_modeldir <- "stan_models"
stan_codedir  <-   "stan_code"
```


## Calculate Summary Statistics

We also want to calculate the summary statistics for each of these customers
based on an observation date of Jan 1 2020.


```{r construct_frequency_modelling_data, echo=TRUE}
customer_summarystats_tbl <- customer_transactions_tbl %>%
  calculate_transaction_cbs_data(
    last_date = as.Date("2020-01-01")
    )

customer_summarystats_tbl %>% glimpse()
```



## Visualise the Transaction Data

As always, we want to visualise this data as much as we can to get a feel for
it, so we construct a plot of each customer.

```{r construct_sample_transaction_visualisations, echo=TRUE}
tnx_plot_tbl <- customer_transactions_tbl %>%
  group_nest(customer_id, .key = "tnx_data") %>%
  filter(map_int(tnx_data, nrow) > 1) %>%
  slice_sample(n = 50) %>%
  unnest(tnx_data)

ggplot(tnx_plot_tbl, aes(x = tnx_timestamp, y = customer_id)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Date",
    y = "Customer ID",
    title = "Visualisation of Transactions for Sample of Customers"
    ) +
  theme(
    axis.text.y = element_text(size = 8)
    )
```



As part of the lifetime analysis, we need to take a look at times between
transactions and we use this as part of our analysis later.

For the moment, we just want to see how the time differences work.

```{r construct_customer_timediff_data, echo=TRUE}
customer_timediffs_tbl <- customer_transactions_tbl %>%
  group_by(customer_id) %>%
  mutate(
    tnx_timediff = difftime(
        tnx_timestamp, lag(tnx_timestamp),
        units = "weeks") %>%
      as.numeric()
    ) %>%
  ungroup()

ggplot(customer_timediffs_tbl %>% drop_na(tnx_timediff)) +
  geom_histogram(aes(x = tnx_timediff), bins = 50) +
  scale_y_continuous(labels = label_comma()) +
  labs(
    x = "Weeks",
    y = "Count",
    title = "Histogram of Weeks Between Successive Transactions"
    )
```

We can see that almost all time differences are less than 75 weeks, but it is
worth looking at a summary of the raw data.

```{r show_customer_tnx_timediffs_summary, echo=TRUE}
customer_timediffs_tbl %>% pull(tnx_timediff) %>% summary()
```

Considering this data, we can say that a customer has 'died' in our model 100
weeks after the most recent transaction. We can use this information in our
model.


## Construct the Model Data

We take a analagous approach for our lifetime model as we did for the
frequency model. We takea subset of the data and use the rest of the data to
validate the model.

```{r construct_10k_data_subset, echo=TRUE}
break_date <- as.Date("2018-01-01")
full_weeks <- difftime(break_date, as.Date("2018-01-01"), units = "weeks") %>%
  as.numeric()

training_tbl <- customer_transactions_tbl %>%
  filter(
    tnx_timestamp <= break_date
    ) %>%
  group_nest(customer_id, .key = "tnx_data") %>%
  slice_sample(n = 10000) %>%
  unnest(tnx_data)

training_tbl %>% glimpse()

test_tbl <- customer_transactions_tbl %>%
  semi_join(training_tbl, by = "customer_id") %>%
  filter(
    tnx_timestamp > break_date
    )

test_tbl %>% glimpse()
```


We need to reconstruct the summary statistics

```{r constructing_model_fit, echo=TRUE}
training_stats_tbl <- training_tbl %>%
  calculate_transaction_cbs_data(
    last_date = break_date
    ) %>%
  mutate(
    min_lifetime = t_x,
    max_lifetime = pmin(t_x + 100, T_cal)
    )

training_stats_tbl %>% glimpse()
```

For model validation purposes, we just need to check for the presence of not
of customer transactions in the `test` set.



# Construct Initial Lifetime Models

We now turn our attention to fitting our model to get estimates of the
lifetime of the customer.

There is one important distinction between our lifetime model and the
frequency model: we do not have direct observations of the lifetime of the
customer.

Instead, what we have an exact observation of each customer's minimum possible
value for the lifetime: the time between the very first transaction that
customer made and the most recently observed transaction.

We know that the customer's lifetime is *at least* this number.







## Fit Flat Model

We start with a simple flat model without any priors like we did for the
frequency models.

```{r compile_ltmodel_flat_stanmodel, echo=TRUE, results="hide"}
ltmodel_flat_stanmodel <- cmdstan_model(
  "stan_code/ltmodel_flat.stan",
  include_paths =   stan_codedir,
  pedantic      =           TRUE,
  dir           =  stan_modeldir
  )
```

We then use this compiled model with our data to produce a fit of the data.

```{r fit_ltmodel_flat_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_flat"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data()

ltmodel_flat_stanfit <- ltmodel_flat_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4201,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_flat_stanfit$summary()
```

We know this model has not fit properly, but we check the HMC diagnostics
anyway.

```{r calculate_ltmodel_flat_hmc_diagnostics, echo=TRUE}
ltmodel_flat_stanfit$cmdstan_diagnose()
```

As we see, this model is not sampling properly at all, but part of the problem
is that we have an implicit uniform prior on $\mu$ - which does not match our
knowledge.


## Fit Fixed-Prior Minimum Time Model

We add a Gamma prior to this model that we set via passing data into the
sampler. As we also have less confidence in our maximum lifetime observation
we also try fitting our model with just the minimum observed lietime per
customer

```{r compile_ltmodel_mintime_stanmodel, echo=TRUE, results="hide"}
ltmodel_mintime_stanmodel <- cmdstan_model(
  "stan_code/ltmodel_mintime.stan",
  include_paths =   stan_codedir,
  pedantic      =           TRUE,
  dir           =  stan_modeldir
  )
```

We then use this compiled model with our data to produce a fit of the data.

```{r fit_ltmodel_mintime_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_mintime"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data(
    s     = 1,
    beta = 10
    )

ltmodel_mintime_stanfit <- ltmodel_mintime_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4202,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_mintime_stanfit$summary()
```

It appears that this fit is much less problematic, so we check the HMC
diagnostics.

```{r calculate_ltmodel_mintime_hmc_diagnostics, echo=TRUE}
ltmodel_mintime_stanfit$cmdstan_diagnose()
```

### Investigate Posterior Distribution of Customer Lifetime

We now want to visualise the posterior distribution of the expected lifetime
of the customer.

```{r construct_posterior_expected_lifetime_validation, echo=TRUE}
ltmodel_mintime_validation_tbl <- ltmodel_mintime_stanfit %>%
  recover_types(training_stats_tbl) %>%
  spread_draws(mu[customer_id], tau[customer_id]) %>%
  ungroup() %>%
  inner_join(customer_simparams_tbl, by = "customer_id") %>%
  select(
    customer_id, draw_id = .draw, post_mu = mu, post_tau_mean = tau,
    customer_mu, customer_tau
    )

ltmodel_mintime_validation_tbl %>% glimpse()
```

We now use our existing routine to compare the posterior values for `mu` with
the predetermined value.

```{r calculate_ltmodel_mintime_qvalues, echo=TRUE}
plotvalid_tbl <- ltmodel_mintime_validation_tbl %>%
  calculate_distribution_qvals(post_mu, customer_mu)

ggplot(plotvalid_tbl) +
  geom_histogram(aes(x = q_val), bins = 50) +
  geom_hline(aes(yintercept = plotvalid_tbl %>% nrow() %>% divide_by(50)), colour = "red") +
  labs(
    x = "Quantile",
    y = "Count",
    title = "Quantile Plot of the q-Values for the Posterior Distribution"
    )

ggplot(plotvalid_tbl) +
  geom_point(aes(x = q_val, y = customer_mu)) +
  labs(
    x = "Quantile",
    y = "Customer Mu",
    title = "Scatterplot of q-Value against Mu"
    )
```


## Fit Fixed-Prior Min/Max Time Model

We now want to see the effect, if any, of including the maximum time in the
model.

```{r compile_ltmodel_minmax_stanmodel, echo=TRUE, results="hide"}
ltmodel_minmax_stanmodel <- cmdstan_model(
  "stan_code/ltmodel_minmax.stan",
  include_paths =   stan_codedir,
  pedantic      =           TRUE,
  dir           =  stan_modeldir
  )
```

With this new model we use the same data again to fit our new model.


```{r fit_ltmodel_minmax_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_minmax"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data(
    s     = 1,
    beta = 10
    )

ltmodel_minmax_stanfit <- ltmodel_minmax_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4203,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_minmax_stanfit$summary()
```

As before, we need to check the HMC diagnostics.

```{r calculate_ltmodel_minmax_hmc_diagnostics, echo=TRUE}
ltmodel_minmax_stanfit$cmdstan_diagnose()
```


### Plot Customer Lifetime Diagnostic Plots

We now want to visualise the posterior distribution of the expected lifetime
of the customer.

```{r construct_posterior_expected_lifetime_validation_minmax, echo=TRUE}
ltmodel_minmax_validation_tbl <- ltmodel_minmax_stanfit %>%
  recover_types(training_stats_tbl) %>%
  spread_draws(mu[customer_id], tau[customer_id]) %>%
  ungroup() %>%
  inner_join(customer_simparams_tbl, by = "customer_id") %>%
  select(
    customer_id, draw_id = .draw, post_mu = mu, post_tau_mean = tau,
    customer_mu, customer_tau
    )

ltmodel_minmax_validation_tbl %>% glimpse()
```

We now use our existing routine to compare the posterior values for `mu` with
the predetermined value.

```{r calculate_ltmodel_minmax_qvalues, echo=TRUE}
plotvalid_tbl <- ltmodel_minmax_validation_tbl %>%
  calculate_distribution_qvals(post_mu, customer_mu)

ggplot(plotvalid_tbl) +
  geom_histogram(aes(x = q_val), bins = 50) +
  geom_hline(aes(yintercept = plotvalid_tbl %>% nrow() %>% divide_by(50)), colour = "red") +
  labs(
    x = "Quantile",
    y = "Count",
    title = "Quantile Plot of the q-Values for the Posterior Distribution"
    )

ggplot(plotvalid_tbl) +
  geom_point(aes(x = q_val, y = customer_mu)) +
  labs(
    x = "Quantile",
    y = "Customer Mu",
    title = "Scatterplot of q-Value against Mu"
    )
```



## Fit Tighter Fixed-Prior Min/Max Time Model

We now fit the same model but with a tighter prior around $\mu$.

```{r fit_ltmodel_tightprior_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_minmax"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data(
    s     = 5,
    beta = 50
    )

ltmodel_tightprior_stanfit <- ltmodel_minmax_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4204,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_tightprior_stanfit$summary()
```

As before, we need to check the HMC diagnostics.

```{r calculate_ltmodel_tightprior_hmc_diagnostics, echo=TRUE}
ltmodel_tightprior_stanfit$cmdstan_diagnose()
```



### Plot Customer Lifetime Diagnostic Plots

Once again we construct validation plots for our data - comparing the
posterior distributions against the known customer value.

```{r construct_posterior_expected_lifetime_validation_tightprior, echo=TRUE}
ltmodel_tightprior_validation_tbl <- ltmodel_tightprior_stanfit %>%
  recover_types(training_stats_tbl) %>%
  spread_draws(mu[customer_id], tau[customer_id]) %>%
  ungroup() %>%
  inner_join(customer_simparams_tbl, by = "customer_id") %>%
  select(
    customer_id, draw_id = .draw, post_mu = mu, post_tau_mean = tau,
    customer_mu, customer_tau
    )

ltmodel_tightprior_validation_tbl %>% glimpse()
```

We now use our existing routine to compare the posterior values for `mu` with
the predetermined value.

```{r calculate_ltmodel_tightprior_qvalues, echo=TRUE}
plotvalid_tbl <- ltmodel_tightprior_validation_tbl %>%
  calculate_distribution_qvals(post_mu, customer_mu)

ggplot(plotvalid_tbl) +
  geom_histogram(aes(x = q_val), bins = 50) +
  geom_hline(aes(yintercept = plotvalid_tbl %>% nrow() %>% divide_by(50)), colour = "red") +
  labs(
    x = "Quantile",
    y = "Count",
    title = "Quantile Plot of the q-Values for the Posterior Distribution"
    )

ggplot(plotvalid_tbl) +
  geom_point(aes(x = q_val, y = customer_mu)) +
  labs(
    x = "Quantile",
    y = "Customer Mu",
    title = "Scatterplot of q-Value against Mu"
    )
```



# Construct the Hierarchical Lifetime Model

We now look at adding uncertainty to our priors, as we did with the frequency
model.

```{r display_ltmodel_hier_stancode, echo=FALSE}
read_lines("stan_code/ltmodel_hier.stan") %>% cat(sep = "\n")
```





## Compile and Fit First Hierarchical Model

We first need to compile this fitted model.

```{r compile_ltmodel_hier_stanmodel, echo=TRUE, results="hide"}
ltmodel_hier_stanmodel <- cmdstan_model(
  "stan_code/ltmodel_hier.stan",
  include_paths = stan_codedir,
  pedantic      =  TRUE,
  dir           = stan_modeldir
  )
```

```{r fit_ltmodel_hier_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_hier"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data(
    mean_p1 =  5,
    mean_p2 = 50,
    
    cov_p1  = 5,
    cov_p2  = 5
    )

ltmodel_hier_stanfit <- ltmodel_hier_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4205,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_hier_stanfit$summary()
```

As before, we need to check the HMC diagnostics.

```{r calculate_ltmodel_hier_hmc_diagnostics, echo=TRUE}
ltmodel_hier_stanfit$cmdstan_diagnose()
```



## Compile and Fit One-Parameter Hierarchical Model


```{r compile_ltmodel_hier_one_stanmodel, echo=TRUE, results="hide"}
ltmodel_hier_one_stanmodel <- cmdstan_model(
  "stan_code/ltmodel_hier_one.stan",
  include_paths = stan_codedir,
  pedantic      =  TRUE,
  dir           = stan_modeldir
  )
```

```{r fit_ltmodel_hier_one_stanmodel, echo=TRUE}
stan_modelname <- "ltmodel_hier_one"

stan_data_lst <- training_stats_tbl %>%
  select(customer_id, obs_time = T_cal, min_lifetime, max_lifetime) %>%
  compose_data(
    mean_p1 =  2,
    mean_p2 = 20,

    s       =  1
    )

ltmodel_hier_one_stanfit <- ltmodel_hier_one_stanmodel$sample(
  data            =                 stan_data_lst,
  chains          =                             4,
  iter_warmup     =                           500,
  iter_sampling   =                           500,
  seed            =                          4205,
  output_dir      =                 stan_modeldir,
  output_basename = str_c("fit_", stan_modelname)
  )

ltmodel_hier_one_stanfit$summary()
```

As before, we need to check the HMC diagnostics.

```{r calculate_ltmodel_hier_one_hmc_diagnostics, echo=TRUE}
ltmodel_hier_one_stanfit$cmdstan_diagnose()
```



# R Environment

```{r show_session_info, echo=TRUE, message=TRUE}
options(width = 120L)
sessioninfo::session_info()
options(width = 80L)
```
